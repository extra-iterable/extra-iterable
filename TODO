zip?

In general i found that zip =>
combine together till length of shortest iterable.

But instead should zip =>
combine together till length of first iterable?

Also arguments of zipLongest
is not consistent with zip



cycle?

Should cycle accept a start index parameter?
It would make sense to be able to start cycle
at a given start index (more generic).
cycle(x, i, n)


compareOn?

It is possible to have *On functions for the following:
compare, isEqual, search*.
Does that look useful?



findLastIndex?

This one isnt present yet.
Should it be called findRightIndex instead.
Ref: lastIndexOf



take*, drop*?

This is available in Haskell.
Is it useful here, or we aleady have a replacement?
take(While)(End), drop*, span, break.



itertools: Python?

We have no means to generate an iterable yet.
Should progressions be a separate package, or just here?



scan / accumulate?

Capturing result of reduce fn looks useful.
accumulate(x, fn, acc)?



tee?

This splits an iterable into n parts.
Basically a vertical chunk.
But isnt it difficult to return multiple iterables?
Could be worth a try? Maybe get to learn something new.



itertools: Rust?

Rust interleave() looks like zip -> concat.
Nothing to do here then?



batching? coalesce? dedup?

Looks like a custom chunk function.
Can this be done with a reduce?



step?

step(x, n) is a customized version of filter.



merge?

merge(xs, fn) &! mergeOn(xs, fn, ths)
This inspired me to look into more deeply.



peekable iterators?

max => [i, v]?



- map.flip (python) swap key-value (compiler class)
- function.iterate
dist/
├─ index.common.js  ( CommonJS )
├─ index.js         ( UMD )
├─ index.min.js     ( UMD, compressed )
├─ index.mjs        ( ES Module )
└─ index.min.mjs    ( ES Module, compressed )

- set.compare using array.compare
- set.union using array.compare ...
